"use client";

import { useEffect, useState } from 'react';

export default function Page() {
  const [isClient, setIsClient] = useState(false);
  const [file, setFile] = useState(null);
  const [result, setResult] = useState(null);
  const [details, setDetails] = useState(null);
  const [usage, setUsage] = useState(null);
  const [planoDeTestes, setPlanoDeTestes] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);
  };

  const calculateCost = (model, promptTokens, completionTokens) => {
    let costPer1KPrompt = 0;
    let costPer1KCompletion = 0;

    if (model.includes("gpt-4")) {
      costPer1KPrompt = 0.03; // USD por 1.000 tokens de entrada (prompt) GPT-4
      costPer1KCompletion = 0.06; // USD por 1.000 tokens de saída (resposta) GPT-4
    } else if (model.includes("gpt-3.5")) {
      costPer1KPrompt = 0.0015; // USD por 1.000 tokens de entrada (prompt) GPT-3.5
      costPer1KCompletion = 0.002; // USD por 1.000 tokens de saída (resposta) GPT-3.5
    }

    const promptCost = (promptTokens / 1000) * costPer1KPrompt;
    const completionCost = (completionTokens / 1000) * costPer1KCompletion;

    return (promptCost + completionCost).toFixed(4); // Retorna com 4 casas decimais
  };

  const handleUpload = async () => {
    if (!file) return alert('Por favor, selecione um arquivo.');

    const formData = new FormData();
    formData.append('file', file);

    setLoading(true);

    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        if (response.status === 429) {
          throw new Error('Limite de cota excedido. Tente novamente mais tarde.');
        }
        throw new Error('Erro ao enviar o arquivo.');
      }

      const data = await response.json();
      setResult(data.pontosDeFuncao);
      setDetails(data.detalhamento);
      setPlanoDeTestes(data.planoDeTestes);
      setUsage(data.usage);

      setFile(null);
    } catch (error) {
      console.error('❌ Erro:', error);
      alert(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: '20px', textAlign: 'center', fontFamily: 'Arial, sans-serif', position: 'relative' }}>
      <h1 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '20px' }}>
        Estimativa de Pontos de Função
      </h1>

      <div
        style={{
          border: '1px solid #ddd',
          padding: '20px',
          borderRadius: '8px',
          backgroundColor: '#f9f9f9',
          display: 'inline-block',
        }}
      >
        <input type="file" onChange={handleFileChange} style={{ margin: '10px 0' }} />
        <button
          onClick={handleUpload}
          disabled={loading || !file}
          style={{
            padding: '10px 20px',
            backgroundColor: loading || !file ? '#ccc' : '#0070f3',
            color: '#fff',
            border: 'none',
            borderRadius: '4px',
            cursor: loading || !file ? 'not-allowed' : 'pointer',
            marginLeft: '10px',
          }}
        >
          Enviar para Análise
        </button>
      </div>

      {(result !== null || details !== null) && (
        <div style={{ marginTop: '20px' }}>
          {details && (
            <table
              style={{
                margin: '20px auto',
                borderCollapse: 'collapse',
                width: '70%',
              }}
            >
              <thead>
                <tr>
                  <th
                    style={{
                      border: '1px solid #ddd',
                      padding: '8px',
                      backgroundColor: '#0070f3',
                      color: '#fff',
                    }}
                  >
                    Detalhamento da Estimativa da Contagem de Pontos por Função
                  </th>
                </tr>
              </thead>
              <tbody>
                {details
                  .split('\n')
                  .map((line, index) => (
                    <tr key={index}>
                      <td style={{ border: '1px solid #ddd', padding: '8px' }}>{line}</td>
                    </tr>
                  ))}
              </tbody>
            </table>
          )}

          {planoDeTestes && (
            <div style={{ marginTop: '20px' }}>
              <h2 style={{ fontSize: '20px', fontWeight: 'bold' }}>Plano de Testes Sugerido</h2>
              <table
                style={{
                  margin: '20px auto',
                  borderCollapse: 'collapse',
                  width: '70%',
                }}
              >
                <tbody>
                  {planoDeTestes
                    .split('\n')
                    .map((line, index) => (
                      <tr key={index}>
                        <td style={{ border: '1px solid #ddd', padding: '8px' }}>{line}</td>
                      </tr>
                    ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      )}

      {loading && (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
          }}
        >
          <div
            style={{
              width: '80px',
              height: '80px',
              border: '8px solid #fff',
              borderTop: '8px solid transparent',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite',
            }}
          ></div>
        </div>
      )}

      <style jsx>{`
        @keyframes spin {
          from {
            transform: rotate(0deg);
          }
          to {
            transform: rotate(360deg);
          }
        }
      `}</style>
    </div>
  );
}




--------------------------------------------------------------------------------------------------------------

import { IncomingForm } from 'formidable';
import fs from 'fs';
import { fileTypeFromBuffer } from 'file-type';
import mammoth from 'mammoth';
import pdfParse from 'pdf-parse';
import OpenAI from 'openai';

export const config = {
  api: {
    bodyParser: false,
  },
};

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default async function handler(req, res) {
  if (req.method === 'POST') {
    const form = new IncomingForm({ keepExtensions: true });

    form.parse(req, async (err, fields, files) => {
      if (err) {
        console.error('❌ Erro ao processar o upload:', err);
        return res.status(500).json({ error: 'Erro ao processar o upload.' });
      }

      const file = files.file;
      const filePath = file.filepath || (Array.isArray(file) ? file[0].filepath : null);

      if (!filePath) {
        return res.status(400).json({ error: 'Arquivo não encontrado.' });
      }

      try {
        const buffer = fs.readFileSync(filePath);
        const fileTypeResult = await fileTypeFromBuffer(buffer);
        const fileType = fileTypeResult ? fileTypeResult.ext : 'unknown';

        let content = '';
        if (fileType === 'pdf') {
          const data = await pdfParse(buffer);
          content = data.text;
        } else if (fileType === 'docx') {
          const result = await mammoth.extractRawText({ buffer });
          content = result.value;
        } else {
          return res.status(400).json({ error: 'Formato de arquivo não suportado.' });
        }

        const promptPF = `Você é um especialista em contagem de Pontos de Função (PF) conforme o Manual de Práticas de Contagem de Pontos de Função (CPM). Avalie o seguinte conteúdo:

"""
${content}
"""

Classifique cada função de acordo com as regras do CPM e calcule o total de Pontos de Função (PF).

✅ **Retorne o resultado da seguinte forma:**
1. **Funções Identificadas:**
   - Entrada Externa (EE): [Descrição] - [Complexidade] - [Pontos]
   - Saída Externa (SE): [Descrição] - [Complexidade] - [Pontos]
   - Consulta Externa (CE): [Descrição] - [Complexidade] - [Pontos]
   - Arquivo Lógico Interno (ALI): [Descrição] - [Complexidade] - [Pontos]
   - Arquivo de Interface Externa (AIE): [Descrição] - [Complexidade] - [Pontos]

2. **Total de Pontos de Função:** [Soma Final]`;

        const responsePF = await openai.chat.completions.create({
          model: 'gpt-4',
          messages: [{ role: 'user', content: promptPF }],
          temperature: 0,
          max_tokens: 1000,
        });

        const detalhamentoPF = responsePF.choices[0]?.message?.content.trim();

        const promptTestes = `Você é um especialista em Análise de Requisitos e Garantia de Qualidade de Software.

Com base nos critérios de aceite descritos no seguinte conteúdo e no detalhamento da contagem de Pontos de Função (PF), gere um Plano de Testes contendo casos de teste relevantes:

"""
${content}
${detalhamentoPF}
"""

✅ **Retorne o resultado no seguinte formato:**

1️⃣ **Casos de Teste Sugeridos:**
- **Caso de Teste 1:** [Descrição do Caso de Teste]
  - **Critério de Aceite:** [Critério associado]
  - **Condições de Entrada:** [Pré-condições necessárias]
  - **Passos para Execução:** [Etapas detalhadas]
  - **Resultado Esperado:** [O que deve acontecer para o teste ser considerado aprovado]
  - **Complexidade:** [Baixa, Média, Alta]

2️⃣ **Resumo do Plano de Testes:**
- Total de Casos de Teste: [Quantidade]
- Cobertura de Critérios de Aceite: [Descrição resumida da cobertura]`;

        const responseTestes = await openai.chat.completions.create({
          model: 'gpt-4',
          messages: [{ role: 'user', content: promptTestes }],
          temperature: 0,
          max_tokens: 1500,
        });

        const planoDeTestes = responseTestes.choices[0]?.message?.content.trim();

        return res.status(200).json({
          pontosDeFuncao: detalhamentoPF.match(/\d+/)?.[0] || '0',
          detalhamento: detalhamentoPF,
          planoDeTestes: planoDeTestes,
        });
      } catch (error) {
        console.error('❌ Erro ao processar o arquivo:', error);
        return res.status(500).json({ error: 'Erro interno ao processar o arquivo.' });
      }
    });
  } else {
    res.setHeader('Allow', ['POST']);
    res.status(405).end(`Método ${req.method} não permitido`);
  }
}
